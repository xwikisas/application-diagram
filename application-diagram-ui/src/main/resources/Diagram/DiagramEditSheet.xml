<?xml version="1.1" encoding="UTF-8"?>

<!--
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-->

<xwikidoc version="1.3" reference="Diagram.DiagramEditSheet" locale="">
  <web>Diagram</web>
  <name>DiagramEditSheet</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <parent>Main.WebHome</parent>
  <author>xwiki:XWiki.Admin</author>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <version>1.1</version>
  <title/>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>true</hidden>
  <content>{{include reference="Diagram.ResourceSelector.WebHome" /}}

{{velocity output="false"}}
#macro (diagramLinkModal)
  &lt;div class="modal" id="diagramLinkModal" tabindex="-1" role="dialog"
      aria-labelledby="diagramLinkModal-label" data-backdrop="static" data-keyboard="false"&gt;
    &lt;div class="modal-dialog modal-lg" role="document"&gt;
      &lt;div class="modal-content"&gt;
        &lt;div class="modal-header"&gt;
          &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt;
            &lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;
          &lt;/button&gt;
          &lt;div class="modal-title" id="diagramLinkModal-label"&gt;
            Link
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="modal-body xform"&gt;
          #resourceSelector()
        &lt;/div&gt;
        &lt;div class="modal-footer"&gt;
          &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;
            $escapetool.xml($services.localization.render('cancel'))
          &lt;/button&gt;
          &lt;button type="button" class="btn btn-primary"&gt;&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
#end
{{/velocity}}

{{velocity}}
{{html clean="false"}}
#if ($doc.getObject('Diagram.DiagramClass'))
  ## Disable the keyboard shortcuts because they prevent the user from typing text inside the diagram (the diagram
  ## editor doesn't use standard text fields for entering the labels for the various shapes the diagram is made of)
  #set ($keyboardShortcutsEnabled = false)
  #set ($discard = $xwiki.ssx.use('Diagram.DiagramSheet'))
  #set ($discard = $xwiki.jsx.use('Diagram.DiagramEditSheet'))
  &lt;div class="diagram-editor loading" data-diagram-config="$escapetool.xml($jsontool.serialize($diagramConfig))"&gt;
    &lt;input class="diagram-content" type="hidden" name="content" value="$escapetool.xml($tdoc.content)" /&gt;
  &lt;/div&gt;
  #diagramLinkModal()
#end
{{/html}}
{{/velocity}}</content>
  <object>
    <name>Diagram.DiagramEditSheet</name>
    <number>1</number>
    <className>XWiki.JavaScriptExtension</className>
    <guid>07b08a89-bce0-494e-89e6-efaef0cfd155</guid>
    <class>
      <name>XWiki.JavaScriptExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <defaultValue>long</defaultValue>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage|onDemand|always</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>/**
 * Adds support for editing diagrams stored in XWiki pages.
 */
define('diagram-store', ['jquery', 'xwiki-meta', 'xwiki-utils', 'diagram-utils', 'diagram-config', 'draw.io',
    'xwiki-events-bridge'], function($, xm, xutils, diagramUtils, diagramConfig) {
  var files = [];
  window._xfiles = files;
  var createFile = function(ui, input, title, documentReference) {
    var file = new XWikiFile(ui, input, title, documentReference);
    files.push(file);
    return file;
  };

  var XWikiFile = function(ui, input, title, documentReference) {
    DrawioFile.call(this, ui);
    this.input = input;
    this.title = title;
    this.documentReference = documentReference;
  };

  mxUtils.extend(XWikiFile, DrawioFile);

  $.extend(XWikiFile.prototype, {
    getMode: function() {
      return 'xwiki';
    },
    getTitle: function() {
      return this.title;
    },
    getData: function() {
      return this.input.val();
    },
    setData: function(data) {
      this.input.val(data);
    },
    // We overwrite the base implementation because we don't want to support files that contain multiple diagrams.
    updateFileData: function() {
      this.setData(mxUtils.getPrettyXml(this.ui.editor.getGraphXml(true, true)));
    },
    open: function() {
      var graphXML = this.getData() || '&lt;mxGraphModel/&gt;';
      var graphNode = mxUtils.parseXml(graphXML).documentElement;
      graphNode.fromStorage = true;
      this.ui.editor.setGraphXml(graphNode);
      this.changeListener = mxUtils.bind(this, function(sender, eventObject) {
        this.setModified(true);
      });
      this.ui.editor.graph.model.addListener(mxEvent.CHANGE, this.changeListener);
    }
  });

  var forEachOpenedFile = function(visitor) {
    files.forEach(function(file) {
      if (file.getUi() &amp;&amp; file.getUi().getCurrentFile() === file) {
        visitor(file);
      }
    });
  };

  var updateFormFields = function(event) {
    forEachOpenedFile(function(file) {
      // This is a workaround for https://github.com/jgraph/drawio/issues/490
      // Stop editing for getting the latest content from diagram
      file.ui.editor.graph.stopEditing(false);
      file.updateFileData();
    });
  };

  var resetDirty = function() {
    forEachOpenedFile(function(file) {
      file.setModified(false);
    });
  };

  var pipeDeferred = function(left, right) {
    left.done($.proxy(right, 'resolve')).fail($.proxy(right, 'reject'));
  };

  var saveBlobAsImageAttachment = function(blob, fileName, documentReference) {
    var attachmentReference = new XWiki.AttachmentReference(fileName, documentReference);
    var uploadAttachment = $.proxy(xutils.uploadAttachment, null, blob, attachmentReference);
    // Avoid creating too many versions of the attachment. Upload the attachment even if we failed to delete it first.
    return xutils.deleteAttachment(attachmentReference).then(uploadAttachment, uploadAttachment);
  };

  var imageCache = {};
  var saveFileAsPNGImageAttachment = function(file) {
    var deferred = $.Deferred();
    file.getUi().exportToCanvas(/* callback */ function(canvas) {
      if (canvas) {
        try {
          canvas.toBlob(function(blob) {
            pipeDeferred(saveBlobAsImageAttachment(blob, 'diagram.png', file.documentReference), deferred);
          });
        } catch(err) {
          deferred.reject();
        }
      } else {
        deferred.reject();
      }
    }, /* width */ null, /* imageCache */ imageCache, /* background */ null, /* error */ function(e) {
      new XWiki.widgets.Notification(
        $jsontool.serialize($services.localization.render('diagram.editor.saveAsImageAttachmentError')), 'error');
      deferred.reject();
    }, /* limitHeight */ null, /* ignoreSelection */ true, /* scale */ diagramConfig.pdfImageExportZoom);
    return deferred.promise();
  };

  var saveFileAsSVGImageAttachment = function(file) {
    var deferred = $.Deferred();
    var svgRoot = file.ui.editor.graph.getSvg(/* background: */ '#ffffff', /* scale: */ null, /* border: */ null,
      /* nocrop: */ true, /* crisp: */ null, /* ignoreSelection: */ true);
    // Embed the images because the PDF exporter might not be able to access them.
    file.ui.convertImages(svgRoot, function() {
      var svg = '&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n' +
        '&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;\n' +
        mxUtils.getXml(svgRoot);
      var blob = new Blob([svg], {type: 'image/svg+xml'});
      pipeDeferred(saveBlobAsImageAttachment(blob, 'diagram.svg', file.documentReference), deferred);
    }, imageCache);
    return deferred.promise();
  };

  var saveFileAsImageAttachments = function(file) {
    // This is a workaround for https://github.com/jgraph/drawio/issues/490
    // Stop editing for getting the latest content from diagram
    file.ui.editor.graph.stopEditing(false);
    // We upload the PNG image even if the SVG upload has failed.
    var pngUpload = $.proxy(saveFileAsPNGImageAttachment, null, file);
    return saveFileAsSVGImageAttachment(file).then(pngUpload, pngUpload);
  };

  var saveFilesAsImageAttachments = function() {
    var uploadDeferred = $.Deferred().resolve();
    forEachOpenedFile(function(file) {
      // We do the next upload even if the previous uploads have failed.
      var nextUpload = $.proxy(saveFileAsImageAttachments, null, file);
      uploadDeferred = uploadDeferred.then(nextUpload, nextUpload);
    });
    return uploadDeferred.promise();
  };

  var uploadInProgress = false;
  // Attach the diagram SVG to the diagram page in order to use it for viewing the diagram and for exporting the diagram
  // to PDF. For this we need to stop the default save until the upload action is completed and trigger it after.
  $(document).on('xwiki:actions:beforeSave', function(event, data) {
    if (!uploadInProgress) {
      uploadInProgress = true;
      event.preventDefault();
      var saveButton = $('input[name=action_save' + (data &amp;&amp; data['continue'] ? 'andcontinue' : '') + ']');
      saveButton.prop('disabled', true);
      saveFilesAsImageAttachments().fail(function(e) {
        new XWiki.widgets.Notification(
          $jsontool.serialize($services.localization.render('diagram.editor.saveAsImageAttachmentError')), 'error');
      }).always(function() {
        saveButton.prop('disabled', false).click();
      });
    } else {
      uploadInProgress = false;
    }
  });

  // We need to update the form fields before the form is validated (for Preview, Save and Save &amp; Continue).
  $(document).on('xwiki:actions:beforePreview xwiki:actions:beforeSave', updateFormFields);

  var submitInProgress = false;
  // Disable the leave confirmation when the form action buttons are used.
  $(document).on('xwiki:actions:cancel xwiki:actions:preview xwiki:actions:save xwiki:document:saved',
    function(event, data) {
      // We reset the dirty field on 'xwiki:actions:save' only if it's not a Save &amp; Continue. Otherwise we wait for
      // 'xwiki:document:saved' to be sure the document was saved.
      if (!data || !data['continue']) {
        submitInProgress = event.type === 'xwiki:actions:preview' || event.type === 'xwiki:actions:save';
        resetDirty();
      }
    });

  $(window).on('beforeunload', function(event) {
    // Update the form fields before the page is unloaded in order to allow the browser to cache their values
    // (Back-Forward and Soft Reload cache). The form fields have already been updated (for validation) if a submit
    // is currently in progress.
    if (!submitInProgress) {
      updateFormFields();
    } else {
      submitInProgress = false;
    }
  });

  return {
    createFile: createFile
  };
});</code>
    </property>
    <property>
      <name>Diagram Store</name>
    </property>
    <property>
      <parse>1</parse>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <object>
    <name>Diagram.DiagramEditSheet</name>
    <number>2</number>
    <className>XWiki.JavaScriptExtension</className>
    <guid>a9be39c0-68be-4333-ac14-93fcee0a275b</guid>
    <class>
      <name>XWiki.JavaScriptExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <defaultValue>long</defaultValue>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage|onDemand|always</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>define('svg-handler', ['jquery'], function($) {
  var lineHeight = 15;
  var spaceWidth = 5;
  var listBorder = 35;
  var addTagSpecificStyle = function(element, s, w, h, htmlConverter, str, alt) {
    switch (getTagName(element)){
      case 'h1':
        alt.setAttribute('font-size', Math.round(s.fontSize + 0.6 * s.fontSize) + 'px');
        alt.setAttribute('font-weight', 'bold');
        break;
      case 'h2':
        alt.setAttribute('font-size', Math.round(s.fontSize + 0.3 * s.fontSize) + 'px');
        alt.setAttribute('font-weight', 'bold');
        break;
      case 'h3':
        alt.setAttribute('font-size', Math.round(s.fontSize + 0.15 * s.fontSize) + 'px');
        alt.setAttribute('font-weight', 'bold');
        break;
      case 'h4':
        alt.setAttribute('font-weight', 'bold');
        break;
      case 'h5':
        alt.setAttribute('font-size', Math.round(s.fontSize - 0.15 * s.fontSize) + 'px');
        alt.setAttribute('font-weight', 'bold');
        break;
      case 'h6':
        alt.setAttribute('font-size', Math.round(s.fontSize - 0.3 * s.fontSize) + 'px');
        alt.setAttribute('font-weight', 'bold');
        break;
      case 'b':
        alt.setAttribute('font-weight', 'bold');
        break;
      case 'i':
        alt.setAttribute('font-style', 'italic');
        break;
      case 'li':
        // Because of the space that is reserved for the bullets delimiters, the list's text is moved more to the
        // right. For simulating the same behavior in svg, the text-anchor is removed for all the elements inside this
        // container, meaning also for ul and ol elements.
        alt.removeAttribute('text-anchor');

        // Adapt elements for XWiki PDF export since links are not displayed when 'a' tag is placed inside a 'text'
        // element.
        var isLinkTag = getTagName(alt) === 'a';

        // Have a bullet for each row.
        var delimiter = document.createElementNS('http://www.w3.org/2000/svg', isLinkTag ? 'text' : 'tspan');
        delimiter.textContent = "•";
        delimiter.setAttribute('x', w - 2 * spaceWidth);
        delimiter.setAttribute('y', h);

        // Move all to a container.
        var container = document.createElementNS('http://www.w3.org/2000/svg', isLinkTag ? 'g' : 'text');
        container.setAttribute('x', w);
        container.setAttribute('y', h);
        container.appendChild(delimiter);

        if (isLinkTag) {
          // The text inside alt is distributed to 'tspan' elements and since they are showned only if are placed
          // under a 'text' parent, we add it between them and the link.
          var text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          // Copy only first child since it refers to the actual text content which, dependending on whether the
          // text needed wrapping or not, is a 'tspan' with either just text inside or with multiple children
          // representing the wrapped text.
          text.appendChild($(alt).children()[0]);
          $(alt).empty();
          alt.appendChild(text);
        }

        // If alt comes from a container, we should preserve the original parent.
        var parent = alt.parentElement;
        container.appendChild(alt);
        if (parent != null) {
          parent.appendChild(container);
          parent.removeAttribute('text-anchor');
        }
        return container;
      case 'ul':
        // See comment from case 'li'.
        alt.removeAttribute('text-anchor');
        break;
      case 'ol':
        // See comment from care 'li'.
        alt.removeAttribute('text-anchor');
        break;
      case 'u':
        alt.setAttribute('text-decoration', 'underline');
        break;
      case 'a':
        var link = document.createElementNS('http://www.w3.org/2000/svg', 'a');
        link.setAttribute('x', w);
        link.setAttribute('y', h);
        link.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', element.href);
        // Add link decorations for the text. Some styles added to a 'g' are not distributed to it's children by FOP,
        // so we do it manually.
        if (getTagName(alt) == 'g') {
          var childNodes = $(alt).children();
          childNodes.each(function() {
            this.setAttribute('fill', '#0000EE');
            this.setAttribute('text-decoration', 'underline');
          });
        } else {
          alt.setAttribute('fill', '#0000EE');
          alt.setAttribute('text-decoration', 'underline');
        }
        alt.removeAttribute('text-anchor');
        // If alt comes from a container, we should preserve the original parent.
        var parent = alt.parentElement;
        link.appendChild(alt);
        if (parent != null) {
          parent.appendChild(link);
        }
        return link;
      default:
        return alt;
    }
    return alt;
  };

  var getStrWidth = function(str, s) {
    return $('&lt;span&gt;&lt;/span&gt;')
      .css({display: 'none', whiteSpace: 'nowrap'})
      .appendTo($('body'))
      .text(str)
      .width();
  };

  var takenCoordinates;
  // Creates a row inside a text element that should be wrapped. The coordinates of the first row are already saved.
  var createRow = function(w, h, rowNb) {
    var row = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
    row.setAttribute('x', w);
    row.setAttribute('y', h);
    if (rowNb &gt; 0) {
      takenCoordinates.push({'w': w, 'h': h});
    }
    return row;
  };

  var wrapText = function(alt, s, w, h, content, contentWidth, maxWidth) {
    var words = content.split(/[\s+]/);
    var wordWidth, rowWidth = 0, rowNb = 0;
    var row = createRow(w, h, rowNb);
    alt.appendChild(row);
    words.each(function(word) {
      word += ' ';
      wordWidth = getStrWidth(word, s);
      if (rowWidth + wordWidth &gt; maxWidth) {
        h += lineHeight;
        row = createRow(w, h, ++rowNb);
        row.textContent = word;
        alt.appendChild(row);
        rowWidth = wordWidth;
      } else {
        row.textContent += word;
        rowWidth += wordWidth;
      }
    });
  };

  /*
   * Consider containerWidth as the maximal width to do the word wrap when needed. Add the inner html only if the
   * element is not a list, since the text should be distributed to children instead of being shown at once. The same
   * is applied for when the text is longer then the containerWidth, since it will be distributed to tspan elements.
   * Shorten the containerWidth send to text wrapper for 'li' elements since in their case an adittional space is
   * added for the bullet delimiter and it shouldn't be included.
  */
  var addTextContent= function(element, htmlConverter, s, containerWidth, alt, w, h) {
    htmlConverter.innerHTML = element.innerText;
    var content = htmlConverter.value;
    var contentWidth = getStrWidth(content, s);
    if (!isListElement(element)) {
      if (contentWidth &gt; containerWidth) {
        containerWidth = isListItem(element) ? containerWidth - listBorder : containerWidth;
        wrapText(alt, s, w, h, content, contentWidth, containerWidth);
      } else {
        alt.textContent = htmlConverter.value;
      }
    }
  };

  var getTagName = function(element) {
    return element &amp;&amp; element.tagName &amp;&amp; element.tagName.toLowerCase();
  };

  var isTextNode = function(node) {
    return node &amp;&amp; node.nodeType === 3;
  };

  var isHeadingElement = function(element) {
    return  ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].indexOf(getTagName(element)) &gt;= 0;
  };

  var isBlockElement = function(element) {
    return ['p', 'div'].indexOf(getTagName(element)) &gt;= 0 || isHeadingElement(element);
  };

  var isListElement = function(element) {
    return ['ul', 'ol'].indexOf(getTagName(element)) &gt;= 0;
  };

  var isInlineElement = function(element) {
    return  ['b', 'i', 'span'].indexOf(getTagName(element)) &gt;= 0;
  };

  var isListItem = function(element) {
    return getTagName(element) === 'li';
  };

  var isNodeWithPartialStyle = function(node, nbOfSiblings) {
    return isTextNode(node) || ((isInlineElement(node) || isBlockElement(node)) &amp;&amp; nbOfSiblings &gt; 1);
  };

  var isParagraphWithPartialStyle = function(node, nbOfSiblings) {
    if (isNodeWithPartialStyle(node, nbOfSiblings)) {
      return true;
    }

    // Consider also indirect children.
    var childNodes = $(node).contents();
    if ($(node).children().length &gt; 0) {
      for (var i = 0; i &lt; childNodes.length; i++) {
        var child = childNodes[i];
        if (isParagraphWithPartialStyle(child, childNodes.length) == true) {
          return true;
        }
      }
    }
    return false;
  };

  var isStyleElement = function(element) {
    if (element == null) { return false; }
    return ['b', 'i', 'u', 'a'].indexOf(getTagName(element)) != -1 || isHeadingElement(element);
  };

  /*
   * Get multiple styles of an element (i.e. b, i, u, a tags)
  */
  var getStylesFromElement = function(element) {
    var styles = [];
    // Partially styled elements are not supported, so consider only the styles of the main element.
    var parentTextLength = element.parentElement.textContent.length;
    if (element.textContent.length == parentTextLength) {
      styles.push(element);
    }
    // Consider also indirect children.
    var childElements = element.getElementsByTagName("*");
    for (i = 0; i &lt; childElements.length; i++) {
      var child = childElements[i];
      if (child.textContent.length == parentTextLength) {
        styles.push(child);
      }
    }
    return styles;
  };

  // For the current block of text take into consideration if those coordinates are already in use.
  // This is used when we are manually computing the container of children elements.
  var maybeChangeHeight = function(w, h, element) {
    // They didn't took into consideration the size of an heading tag.
    h = isHeadingElement(element) ? h - lineHeight : h;
    var thisCoordinates = {'w': w, 'h': h};
    takenCoordinates.each(function(coordinates) {
      if (coordinates['w'] == thisCoordinates['w'] &amp;&amp; coordinates['h'] == thisCoordinates['h']) {
        h += lineHeight;
        thisCoordinates['h'] = h;
      }
    });
    takenCoordinates.push(thisCoordinates);
    return h;
  };

  var getAdjustedInitialCoordinates = function(w, h, fontSize) {
    w = Math.round(w / 2);
    // For smaller heights the result seems to corespond to the one in the original view, but for the others the font
    // size is relevant.
    // TODO: investigate the reasons behind this behavior.
    if (h &lt; lineHeight) {
      h = Math.round(h / 2);
    } else {
      h = Math.round(h / 2 - fontSize / 2);
    }
    return {'w': w, 'h': h};
  }

  // Create the basis of a svg element. Calculate new coordinates if is needed.
  var createSvgElement = function(s, w, h, tag, element, addAnchor, isPartiallyStyledElement) {
    var alt = document.createElementNS('http://www.w3.org/2000/svg', tag);
    if (element &amp;&amp; (isBlockElement(element) || isListItem(element) || isPartiallyStyledElement)) {
      h = maybeChangeHeight(w, h, element);
    }
    alt.setAttribute('x', w);
    alt.setAttribute('y', h);
    alt.setAttribute('fill', s.fontColor || 'black');
    if (addAnchor) {
      alt.setAttribute('text-anchor', 'middle');
    }
    alt.setAttribute('font-size', Math.round(s.fontSize) + 'px');
    alt.setAttribute('font-family', s.fontFamily);

    if ((s.fontStyle &amp; mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)
    {
      alt.setAttribute('font-weight', 'bold');
    }

    if ((s.fontStyle &amp; mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)
    {
      alt.setAttribute('font-style', 'italic');
    }

    if ((s.fontStyle &amp; mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)
    {
      alt.setAttribute('text-decoration', 'underline');
    }
    return alt;
  };

  var convertTextElementToSvg = function(element, s, w, h, htmlConverter, str, containerWidth, isFirstChild) {
    if (getTagName(element) == 'br') {
      return document.createElementNS('http://www.w3.org/2000/svg', "text");
    }
    if (isFirstChild) {
      takenCoordinates = [];
    }
    var coordinates = getAdjustedInitialCoordinates(w, h, s.fontSize);
    w = coordinates.w;
    h = coordinates.h;

    // Use 'tspan' for 'li' elements since they will be move inside a 'text' container along with a row delimiter.
    // Update h in case it was manually modified to take into consideration other inserted elements.
    var tag = isListItem(element) ? 'tspan' : 'text';
    var alt = createSvgElement(s, w, h, tag, element, true);
    h = parseInt(alt.getAttribute('y'));

    addTextContent(element, htmlConverter, s, containerWidth, alt, w, h);

    // Convert recursively the children. Have a container that will hold the elements in case there are other children.
    // Consider the case when multiple styles are added to an element (e.g. &lt;i&gt;&lt;b&gt;txt&lt;/b&gt;&lt;/i&gt;).
    // Traverse all children and keep the styles to just one element.
    if (element.childElements().length &gt; 0) {
      var container = createSvgElement(s, w, h, 'g', null, !isListElement(element));
      // TODO: Don't append alt element, unless it has a content.
      container.appendChild(alt);
      element.childElements().each(function(child) {
        if (isStyleElement(child)) {
          var styles = getStylesFromElement(child);
          styles.each(function(style) {
            alt = addTagSpecificStyle(style, s, w, h, htmlConverter, str, alt, true);
          });
        } else {
          var childSvg = convertTextElementToSvg(child, s, w, h, htmlConverter, str, containerWidth, false);
          if (childSvg != undefined) {
            container.appendChild(childSvg);
          }
        }
      });
    }

    // TODO: apply the defined style of the element.
    alt = addTagSpecificStyle(element, s, w, h, htmlConverter, str, alt);
    if (element.childElements().length &gt; 0) {
      return container;
    } else {
      return alt;
    }
  };


  /*
   * Converts a partially styled element (e.g. link added to just a word of a phrase) to svg kepping as much as
   * possible from the original element.
   * When different types of elements are separated vertically (see Example 1), as long as each element is not a
   * composite one, the result is mainly as the input. But, for cases when the styled element is inside a phrase (see
   * Example 2), the result is a fallback to simple text.
   * TODO: In the case of Example 3, when a child of a partially styled paragraph is itself a partially styled
   * paragraph with "Text" nodes a fallback must be added. For now, elementsContainer.contents() separates the nodes
   * that are connected and there isn't a smooth solution to get which elements were on the same line (maybe consider
   * &lt;/br&gt; as divider). Even though it looks the same in html, Example 4 works compared to 3 since there are
   * no text nodes, but this depends on how the user inserts the text.
   *
   * Example 1: &lt;div&gt; "Simple text" &lt;/br&gt; &lt;b&gt;Bolded text&lt;/b&gt; &lt;/div&gt;
   * Example 2: &lt;div&gt; "Simple text" &lt;b&gt;Bolded text&lt;/b&gt; &lt;/div&gt;
   * Example 3: &lt;div&gt; "Simple text" &lt;/br&gt; "Simple text" &lt;b&gt;Bolded text&lt;/b&gt; &lt;/div&gt;
   * Example 4:
   * &lt;div&gt;
   * "Simple text" &lt;/br&gt;
   * &lt;span&gt;"Simple text" &lt;b&gt;Bolded text&lt;/b&gt;&lt;/span&gt;
   * &lt;/div&gt;
  */
  var convertPartiallyStyledParagraphToSVG = function(childNodes, s, w, h, htmlConverter, str, containerWidth) {
    takenCoordinates = [];
    var initialWidth = w;
    var initialHeight = h;
    var coordinates = getAdjustedInitialCoordinates(w, h, s.fontSize);
    w = coordinates.w;
    h = coordinates.h;

    var container = createSvgElement(s, w, h, /* tag */ 'g', /* element */ null,
        /* addAnchor */ !isListElement(childNodes[0]));
    // Go to last level of child nodes in case there is a style added to the root element. Keep the styles to add
    // them after assembling the element with its children.
    var styles = [];
    while (childNodes.length == 1 &amp;&amp; $(childNodes[0]).children().length &gt; 0) {
      var rootNode = childNodes[0];
      if (isStyleElement(rootNode)) {
        styles.push(rootNode);
      }
      childNodes = $(rootNode).contents();
    }

    // Resolve the basic case where the element is just a phrase with a styled element. Remove this after fixing
    // the TODO described in the comment above.
    var simpleNodes= childNodes.filter(function() {
      return isTextNode(this) || isInlineElement(this);
    });

    if(simpleNodes.length == childNodes.length) {
      var element = $('&lt;span&gt;&lt;/span&gt;').html(str)[0];
      // We use the unmodified coordinates to prevent adjusting them twice.
      var alt = convertTextElementToSvg(element, s, initialWidth, initialHeight, htmlConverter, str, containerWidth,
          /* isFirstChild */ true);
      return alt;
    }

    // Look only on first-level children since for now it is not supported to partially style paragraphs inside a
    // partially styled paragraph.
    childNodes.each(function(index) {
      var element = $(this).clone()[0];
      // Convert text content to element for consistency.
      if (isTextNode(element)) {
        element = $('&lt;span&gt;&lt;/span&gt;').html(element.textContent)[0];
      }

      // Don't do anything for &lt;/br&gt; tags or empty elements.
      if (getTagName(element) == 'br' || element.innerText == '') {
        return;
      }

      // Consider that list elements will be moved to a 'text' container and in this case 'tspan' should be used as
      // child tag. Specify that it is a partially styled element because in this case it could contain '&lt;br&gt;'
      // tags and the children would need to have changed coordinates (heights) when they are created.
      var alt = createSvgElement(s, w, h, /* tag */ isListItem(element) ? 'tspan' : 'text', /* element */ element,
          /* addAnchor */ true, /* isPartiallyStyledElement */ true);
      h = parseInt(alt.getAttribute('y'));

      addTextContent(element, htmlConverter, s, containerWidth, alt, w, h);

      alt = addTagSpecificStyle(element, s, w, h, htmlConverter, str, alt);
      container.appendChild(alt);
    });
    // Consider the case when multiple styles are added to the root element.
    styles.each(function(style) {
      container = addTagSpecificStyle(style, s, w, h, htmlConverter, str, container, true);
    });
    return container;

  };

  // Fix the transform attribute of the element that is used when foreignObjects are not supported and the view
  // fallbacks to svg. This code is taken from an older draw.io version, since starting with 12.5.0 the transform
  // attribute doesn't take into consideration the coordinates, but only the foOffset.
  var adjustAlternateTextCoordinates = function(group, x, y , w , h, s, align, valign, overflow, rotation, foOffset) {
    x += s.dx;
    y += s.dy;
    var dx = 0;
    var dy = 0;

    if (align == mxConstants.ALIGN_CENTER) {
      dx -= w / 2;
    } else if (align == mxConstants.ALIGN_RIGHT) {
      dx -= w;
    }
    x += dx;

    if (valign == mxConstants.ALIGN_MIDDLE) {
      dy -= h / 2;
    } else if (valign == mxConstants.ALIGN_BOTTOM) {
      dy -= h;
    }

    if (overflow != 'fill' &amp;&amp; mxClient.IS_FF &amp;&amp; mxClient.IS_WIN) {
      dy -= 2;
    }
    y += dy;

    var tr = (s.scale != 1) ? 'scale(' + s.scale + ')' : '';

    if (s.rotation != 0 &amp;&amp; this.rotateHtml) {
      tr += 'rotate(' + (s.rotation) + ',' + (w / 2) + ',' + (h / 2) + ')';
      var pt = this.rotatePoint((x + w / 2) * s.scale, (y + h / 2) * s.scale, s.rotation, s.rotationCx, s.rotationCy);
      x = pt.x - w * s.scale / 2;
      y = pt.y - h * s.scale / 2;
    } else {
      x *= s.scale;
      y *= s.scale;
    }

    if (rotation != 0) {
      tr += 'rotate(' + (rotation) + ',' + (-dx) + ',' + (-dy) + ')';
    }

    var transform = 'translate(' + (Math.round(x) + foOffset) + ',' + (Math.round(y) + foOffset) + ')' + tr;
    group.setAttribute('transform', transform);
  };

  return {
    convertTextElementToSvg: convertTextElementToSvg,
    isParagraphWithPartialStyle: isParagraphWithPartialStyle,
    convertPartiallyStyledParagraphToSVG: convertPartiallyStyledParagraphToSVG,
    adjustAlternateTextCoordinates: adjustAlternateTextCoordinates
  };
});
/**
 * Overrides the link dialog in order to support creating links to wiki pages.
 */
define('diagram-link-editor', [
  'jquery',
  'diagram-link-handler',
  'svg-handler',
  'draw.io',
  'resourceSelector'
], function($, diagramLinkHandler, svgHandler) {
  EditorUi.prototype.showLinkDialog = function(value, selectLabel, callback) {
    var resourceReference = diagramLinkHandler.getResourceReferenceFromCustomLink(value);
    // We append the modal to the body element in order to fix Issue #108: "Inserting a link in full screen mode is not
    // possible".
    $('#diagramLinkModal').appendTo('body').selectResource(resourceReference, {
      selectLabel: selectLabel
    }).done(function(resourceReference) {
      callback(diagramLinkHandler.getCustomLinkFromResourceReference(resourceReference));
    });
  };

  // For some cases, to consider wrapping or overflow, w might be altered and we need to keep the initial value as
  // it was from bounds.width of the base mxText node.
  var originalText = mxSvgCanvas2D.prototype.text;
  mxSvgCanvas2D.prototype.text = function(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir) {
    this.state.initialWidth = w;
    return originalText.apply(this, arguments);
  };

  // Don't add warning when the viewer doesn't support SVG 1.1, since we create a fallback for foreignObjects.
  Graph.prototype.addForeignObjectWarning = function(canvas, root) {
    // Do nothing.
  }

  // Overwrite Graph.getSvg in order to replace XWiki custom links with absolute URLs.
  // Also fix the text fallback for viewers with no support for foreignObjects.
  var originalGraphGetSVG = Graph.prototype.getSvg;
  Graph.prototype.getSvg = function(background, scale, border, nocrop, crisp, ignoreSelection, showText, imgExport,
      linkTarget, hasShadow, incExtFonts, keepTheme, exportType, cells) {
    imgExport = imgExport || this.createSvgImageExport();
    var originalGetLinkForCellState = imgExport.getLinkForCellState;
    imgExport.getLinkForCellState = function() {
      var result = originalGetLinkForCellState.apply(this, arguments);
      if (diagramLinkHandler.isXWikiCustomLink(result)) {
        result = diagramLinkHandler.getURLFromCustomLink(result);
        // Use the absolute URL because this SVG is used for PDF export which needs to be portable.
        result = $('&lt;a/&gt;').attr('href', result).prop('href');
      }
      return result;
    }
    var originalDrawState = imgExport.drawState;
    imgExport.drawState = function(state, canvas) {
      var originalCreateAlternateContent = canvas.createAlternateContent;
      canvas.createAlternateContent = function(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip,
          rotation) {
        if (format === 'html') {
          // Keep only the text content.
          str = $('&lt;div/&gt;').html(str).text() || this.foAltText;
        }
        // Update links inside foreignObject to use absolute URLs, since the generated SVG needs to be portable.
        $(fo).find('a').each(function() {
          var oldLink = $(this).attr('href');
          if (diagramLinkHandler.isXWikiCustomLink(oldLink)) {
            var newLink = diagramLinkHandler.getURLFromCustomLink(oldLink);
            $(this).attr('href', newLink);
          }
        });

        if (this.foAltText != null) {
          var s = this.state;
          var htmlConverter = document.createElement('textarea');
          var content = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          var temporaryContent = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          var elementsContainer = $(fo).children().first().children().first();
          var childNodes = elementsContainer.contents();
          // Consider the container width to be the width of the closest rect parent node. For some shapes, like Actor
          // or any non squared shape, there is no rect and we fallback to the initial width of the text node, which is
          // less accurate.
          var containerWidth = this.state.initialWidth;
          var prevNode = $(fo.parentNode).prev()[0];
          if (prevNode &amp;&amp; prevNode.nodeName == 'rect') {
            var containerWidth = prevNode.width.baseVal.valueAsString;
          }
          try {
            if (childNodes.length &gt; 0) {
              var isPartiallyStyledElement = false;
              var alt;
              childNodes.each(function(index) {
                // Make a clone of the node, to not alter the original child.
                var node = $(this).clone()[0];
                // If this paragraph has partially styled nodes (i.e. link added to just a part of the text) create a
                // fallback version of it, since not all the cases are supported and the created svg could not be
                // compatible with the already created elements. This is done since is too complex to calculate the
                // coordinates of the styled node, considering the last element added and that it may be needed to wrap
                // the text.
                if (svgHandler.isParagraphWithPartialStyle(node, childNodes.length)) {
                  alt = svgHandler.convertPartiallyStyledParagraphToSVG(childNodes, s, w, h, htmlConverter, str,
                    containerWidth);
                  isPartiallyStyledElement = true;
                  return false;
                } else {
                  alt = svgHandler.convertTextElementToSvg(node, s, w, h, htmlConverter, str, containerWidth, index == 0);
                  temporaryContent.appendChild(alt);
                }
              });
              content.appendChild(isPartiallyStyledElement ? alt : temporaryContent)
              svgHandler.adjustAlternateTextCoordinates(content, x, y, w, h, s, align, valign, overflow, rotation,
                this.foOffset);
              return content;
            } else {
              return originalCreateAlternateContent.call(this, fo, x, y, w, h, str, align, valign, wrap, format,
                overflow, clip, rotation);
            }
          } catch (e) {
            return originalCreateAlternateContent.apply(this, arguments);
          }
        } else {
          return originalCreateAlternateContent.apply(this, arguments);
        }
      };
      return originalDrawState.apply(this, arguments);
    };
    try {
      return originalGraphGetSVG.call(this, background, scale, border, nocrop, crisp, ignoreSelection, showText,
        imgExport, linkTarget, hasShadow, incExtFonts, keepTheme, exportType, cells);
    } finally {
      imgExport.getLinkForCellState = originalGetLinkForCellState;
      imgExport.drawState = originalDrawState;
    }
  };
});

/**
 * Adds support for using XWiki image attachments in diagrams.
 */
define('diagram-image-editor', ['xwiki-utils', 'diagram-link-handler', 'draw.io'], function(xutils, diagramLinkHandler) {
  // Fix the base URL used when exporting the diagram as image.
  var originalCreateImageUrlConverter = EditorUi.prototype.createImageUrlConverter;
  EditorUi.prototype.createImageUrlConverter = function() {
    var converter = originalCreateImageUrlConverter.call(this);
    converter.convert = function(src) {
      // Use baseDomain instead of baseUrl to detect external URLs.
      if (src &amp;&amp; (src.substr(0, 7) === 'http://' || src.substr(0, 8) === 'https://') &amp;&amp;
          src.substr(0, converter.baseDomain.length) !== converter.baseDomain) {
        src = PROXY_URL + '?url=' + encodeURIComponent(src);
      }
      return src;
    };
    return converter;
  };

  // Override for uploading the image as attachment instead of encode it to Base64.
  var originalImportFiles = EditorUi.prototype.importFiles;
  EditorUi.prototype.importFiles = function(files, x, y, maxSize, fn, resultFn, filterFn, barrierFn, resizeDialog,
      maxBytes, resampleThreshold, ignoreEmbeddedXml, evt) {
    let importFilesArgs = arguments;
    if (fn) {
      let editorUi = this;
      importFilesArgs = Array.prototype.slice.call(arguments);
      // This is the call back function responsible to insert the image.
      importFilesArgs[4] = function(data, mimeType, x, y, w, h, filename) {
        if (data.substring(0, 5) == 'data:') {
          let fnArgs = Array.prototype.slice.call(arguments);
          let fileBase64Data = data.substring(data.indexOf(',') + 1);
          xutils.uploadAttachment(editorUi.base64ToBlob(fileBase64Data, mimeType), filename).done(function() {
            // Include the attachment reference in the URL using the fragment identifier in order to be able to use it
            // when saving the diagram (we want to save the attachment reference not the attachment URL).
            let resourceReference = {
              type: 'attach',
              reference: XWiki.Model.serialize(new XWiki.AttachmentReference(filename))
            };
            let customLink = diagramLinkHandler.getCustomLinkFromResourceReference(resourceReference);
            fnArgs[0] = xutils.getAttachmentURL(filename) + '#' + encodeURIComponent(customLink);
            fn.apply(this, fnArgs);
          });
        } else {
          fn.apply(this, arguments);
        }
      };
    }
    originalImportFiles.apply(this, importFilesArgs);
  };

  // Add support for inserting images by specifying the XWiki attachment reference.
  var originalShowImageDialog = EditorUi.prototype.showImageDialog;
  EditorUi.prototype.showImageDialog = function(title, value, fn, ignoreExisting, convertDataUri) {
    var showImageDialogArgs = Array.prototype.slice.call(arguments);
    var customLink = diagramLinkHandler.getCustomLinkFromURL(value);
    if (customLink) {
      // Edit the XWiki custom link instead of the actual URL.
      showImageDialogArgs[1] = customLink;
    }
    if (typeof fn === 'function') {
      showImageDialogArgs[2] = function(newValue, width, height) {
        var fnArgs = Array.prototype.slice.call(arguments);
        if (diagramLinkHandler.isXWikiCustomLink(newValue)) {
          // Save the actual URL, but keep the custom link as fragment identifier.
          fnArgs[0] = diagramLinkHandler.getURLFromCustomLink(newValue) + '#' + encodeURIComponent(newValue);
        }
        fn.apply(this, fnArgs);
      };
    }
    originalShowImageDialog.apply(this, showImageDialogArgs);
  };

  // This function is used by the image dialog to preload the images before inserting them. We have to overwrite it in
  // order to make it use the actual URL for XWiki image attachments.
  var originalLoadImage = EditorUi.prototype.loadImage;
  EditorUi.prototype.loadImage = function(uri, onload, onerror) {
    var loadImageArgs = Array.prototype.slice.call(arguments);
    if (diagramLinkHandler.isXWikiCustomLink(uri)) {
      loadImageArgs[0] = diagramLinkHandler.getURLFromCustomLink(uri);
    }
    originalLoadImage.apply(this, loadImageArgs);
  };
});

/**
 * Customizes the diagram export as URL and the diagram import from URL.
 */
define('diagram-url-io', ['diagram-utils', 'draw.io'], function(diagramUtils) {
  var urlParam = function(parameter, url) {
    var results = new RegExp('[\?&amp;]' + parameter + '=([^&amp;#]*)').exec(url);
    if (results === null) {
       return null;
    }
    return decodeURIComponent(results[1]);
  };

  var getParameterValueFromURL = function(parameter, url) {
    if (typeof URLSearchParams === 'function') {
      return new URL(url, window.location.href).searchParams.get(parameter);
    }
    // IE will get here since it's not supporting URLSearchParams.
    return urlParam(parameter, url);
  };

  // Custom diagram import from URL.
  var loadUrl = function(url) {
    var diagramXML = null;
    let exportedUrl = getParameterValueFromURL('url', url);
    if (exportedUrl) {
      diagramXML = diagramUtils.getDiagramXMLFromURL(exportedUrl);
    }
    return diagramXML;
  };

  // Custom diagram export as URL (using the current host).
  var originalCreateLink = EditorUi.prototype.createLink;
  EditorUi.prototype.createLink = function() {
    let rawURL = originalCreateLink.apply(this, arguments);
    // Do not include '#' because it's automatically added by getURL function below.
    let documentFragmentIndex = rawURL.indexOf('#');
    let documentFragment = rawURL.substring(documentFragmentIndex + 1);
    if (documentFragment.substring(0, 1) == 'R') {
      let queryString = '';
      let queryStringIndex = rawURL.indexOf('?');
      if (queryStringIndex &gt; -1) {
        queryString = rawURL.substring (queryStringIndex + 1, documentFragmentIndex);
      }
      // Append source parameter to the query
      queryString += '&amp;source=url';
      return window.location.protocol + '//' + window.location.host +
        new XWiki.Document('DiagramViewSheet', 'Diagram').getURL('view', queryString, documentFragment);
    }
    return rawURL;
  }

  return {
    loadUrl: loadUrl
  };
});

/**
  * In case external services are disabled, stop the features that require it (export of pdf from diagram editor
  * or png / jpeg export on IE) and show an info dialog.
  */
define('diagram-external-services', ['jquery', 'diagram-config', 'draw.io'], function($, diagramConfig) {
  var showDisabledServicesDialog = function(editorUi) {
    var errorMessage = $('&lt;div&gt;&lt;/div')
      .html($jsontool.serialize($services.localization.render('diagram.editor.disabledExternalServices')));

    errorMessage.addClass('externalServicesDialog');
    var dlg = new CustomDialog(/*editorUi*/ editorUi, /*content*/ errorMessage[0], /*okFn*/ null, /*cancelFn*/ null,
                               /*okButtonText*/ mxResources.get('ok'), /*helpLink*/ null, /*buttonsContent*/ null,
                               /*hideCancel*/ true);
    editorUi.showDialog(dlg.container, 250, 75, true, true);
  };

  // This is used from File -&gt; Export as.
  var originalCreateDownloadRequest = EditorUi.prototype.createDownloadRequest;
  EditorUi.prototype.createDownloadRequest = function(filename, format, ignoreSelection, base64, transparent,
      currentPage, scale, border, grid, includeXml) {
    if (diagramConfig.disableExternalServices) {
      showDisabledServicesDialog(this);
      return;
    }
    return originalCreateDownloadRequest.apply(this, arguments);
  };

  // This is used from File -&gt; Export as -&gt; Advanced...
  var originalExportFile = ExportDialog.exportFile;
  ExportDialog.exportFile = function(editorUi, name, format, bg, s, b, dpi) {
    if (diagramConfig.disableExternalServices &amp;&amp; (format == 'pdf' ||
        (['png', 'jpg', 'jpeg'].indexOf(format) != -1 &amp;&amp; !editorUi.isExportToCanvas()))) {
      showDisabledServicesDialog(editorUi);
      return;
    }
    return originalExportFile.apply(this, arguments);
  };
});

/**
 * Integrates draw.io diagram editor in XWiki.
 */
define('diagram-editor', [
  'jquery',
  'diagram-store',
  'diagram-utils',
  'diagram-url-io',
  'diagram-config',
  'diagram-graph-xml-filter',
  'diagram-link-editor',
  'diagram-image-editor',
  'diagram-external-services'
], function($, diagramStore, diagramUtils, diagramUrlIO, diagramConfig) {

  // These variables are used to decide if an image should be uploaded at original resolution or
  // should be declined for being too big.
  // Default values:
  // EditorUi.prototype.maxImageSize = 520;
  // EditorUi.prototype.maxImageBytes = 1000000;

  //
  // Diagram Editor Constructor.
  //
  var createDiagramEditor = function(options) {
    options = options || {};
    // This is needed since we do not use drafts and it would create the file to soon, leading to the file being opened
    // in a new window.
    EditorUi.enableDrafts = false;
    var editor = new Editor(/* chromeless: */ uiTheme === 'min', options.themes, /* model: */ null, /* graph: */ null,
      /* editable: */ true);
    var editorUI = new App(editor, options.container);
    // This is usefull for debugging the diagram editor from the JavaScript console.
    $(editorUI.container).data('diagramEditor', editorUI).trigger('diagramEditorCreated', editorUI);
    // Fix the editor UI before loading the diagram because layout changes can influence the way the shapes are drawn.
    fixEditorUI(editorUI);
    fixLoadUrl(editorUI);
    var file = diagramStore.createFile(editorUI, options.input, options.fileName, options.documentReference);
    // The first letter of the file name is used to determine the storage type. Let's use 'X' for XWiki storage.
    editorUI.loadFile('X' + options.fileName, true, file);
    return editorUI;
  };

  var fixEditorUI = function(editorUI) {
    cleanMenu(editorUI);
    fixKeyboardShortcutsAction(editorUI);
    removeCompactModeToggle(editorUI);
    fixFullScreenToggle(editorUI);
    fixEditorButtons($(editorUI.container));
  };

  var fixLoadUrl = function(editorUI) {
    // Custom diagram import from URL.
    var originalLoadUrl = editorUI.editor.loadUrl;
    editorUI.editor.loadUrl = function(url, success, error, forceBinary, retry, dataUriPrefix, noBinary, headers) {
      var diagramXML = diagramUrlIO.loadUrl(url);
      if (diagramXML != null) {
        return success(diagramXML);
      }
      return originalLoadUrl.apply(this, arguments);
    };
  };

  //
  // Disable the tabbed UI (setting urlParams['pages'] to '0' is not enough..)
  //
  EditorUi.prototype.initPages = function() {
    // Do nothing.
  };

  //
  // Change the service name in order to disable notifications.
  //
  EditorUi.prototype.getServiceName = function()
  {
    return 'xwiki.com';
  };

  // Don't change the document title.
  App.prototype.updateDocumentTitle = function() {};

  //
  // Add support for disabling an entire sub-menu.
  //
  var originalAddSubmenu = Menus.prototype.addSubmenu;
  Menus.prototype.addSubmenu = function(name, menu, parent) {
    var subMenu = this.get(name);
    if (subMenu &amp;&amp; subMenu.visible !== false) {
      originalAddSubmenu.apply(this, arguments);
    }
  };

  // Remove the language picker because the diagram editor is configured to use the XWiki language.
  var originalCreateMenubar = Menus.prototype.createMenubar;
  Menus.prototype.createMenubar = function(container) {
    delete this.menus['language'];
    return originalCreateMenubar.apply(this, arguments);
  }

  //
  // Add support for not displaying 'browser' option from 'Import from' sub-menu
  //
  var originalAddItem = mxPopupMenu.prototype.addItem;
  mxPopupMenu.prototype.addItem = function(title, image, funct, parent, iconCls, enabled, active) {
    if (title === (mxResources.get('browser') + '...') &amp;&amp; parent &amp;&amp; parent.innerText === 'Import from') {
      return null;
    }
    return originalAddItem.apply(this, arguments);
  };

  //
  // Clean the editor menu by removing the features that are not needed.
  //
  var cleanMenu = function(editorUI) {
    // Disable and hide some of the menu entries.
    [
      // File menu
      'synchronize', 'new', 'open', 'save', 'saveAs', 'rename', 'makeCopy', 'close',
      // Extras menu
      'autosave', 'showStartScreen', 'plugins', 'offline', 'chromeApp',
       // Help menu
      'downloadDesktop', 'useOffline',
      // ExportAs
      'exportHtml'
    ].forEach(function(actionName) {
      var action = editorUI.actions.actions[actionName];
      if (action) {
        action.enabled = action.visible = false;
      }
    });

    // Disable and hide some of the sub-menus.
    [
      // File menu
      'openFrom', 'openRecent', 'publish', 'embed',
      // Extras menu
      'theme'
    ].forEach(function(name) {
      var subMenu = editorUI.menus.get(name);
      if (subMenu) {
        subMenu.enabled = subMenu.visible = false;
      }
    });
  };

  //
  // Fix the side bar tool tip: the tool tip position is computed as if the editor takes the full screen.
  //
  Sidebar.prototype.getTooltipOffset = function() {
    // Adjust the tool tip coordinates with the editor offset.
    var offset = $(this.editorUi.container).offsetParent().offset();
    return {x: offset.left, y: offset.top};
  };

  //
  // Consider the basePath for the shapes added in the left panel.
  //
  var oldCreateVertexTemplateEntry = Sidebar.prototype.createVertexTemplateEntry;
  Sidebar.prototype.createVertexTemplateEntry = function(style, width, height, value, title, showLabel, showTitle, tags) {
    style = style.replace(/(image=)(img\/lib)/g, '$1' + diagramConfig.drawIOBasePath + '$2');
    return oldCreateVertexTemplateEntry.call(this, style, width, height, value, title, showLabel, showTitle, tags);
  };

  //
  // Overwrite the Keyboard Shortcuts action because it uses the wrong URL.
  //
  var fixKeyboardShortcutsAction = function(editorUI) {
    var keyboardShortcutsAction = editorUI.actions.get('keyboardShortcuts');
    if (keyboardShortcutsAction) {
      var originalFunct = keyboardShortcutsAction.funct;
      keyboardShortcutsAction.funct = function() {
        if (mxClient.IS_SVG) {
          window.open(diagramEditorBasePath + 'shortcuts.svg');
        } else {
          originalFunct.apply(this, arguments);
        }
      };
    }
  };

  //
  // Remove the compact mode toggle and update the position of the remaining buttons.
  //
  var removeCompactModeToggle = function(editorUI) {
    if (typeof editorUI.toggleCompactMode === 'function') {
      editorUI.toggleCompactMode(/* visible: */ false);
      var buttons = $(editorUI.container).find('.geToolbarContainer &gt; a.geButton');
      buttons.last().remove();
      buttons.css('right', function(index, value) {
        return (parseInt(value) - 16) + 'px';
      });
    }
  };

  var fullScreen = new XWiki.widgets.FullScreen();
  var fixFullScreenToggle = function(editorUI) {
    mxEvent.removeAllListeners(editorUI.fullscreenElement);
    editorUI.container._x_fullScreenActivator = editorUI.fullscreenElement;
    $(editorUI.fullscreenElement).click(function(event) {
      event.preventDefault();
      var isFullScreen = $(editorUI.container).parent('.fullScreenWrapper').length &gt; 0;
      if (isFullScreen) {
        // Exit full screen mode.
        fullScreen.closeFullScreen();
        editorUI.refresh();
      } else {
        // Enter full screen mode.
        fullScreen.makeFullScreen(editorUI.container);
        // The previous line hides the 'fullScreenActivator' and shows the 'Exit Full Screen' button. We want to use the
        // 'fullScreenActivator' for exiting the full screen mode. The 'Exit Full Screen' button is hidden from CSS.
        $(editorUI.fullscreenElement).show();
        editorUI.refresh();
      }
    });
  };

  //
  // Add the type of the buttons manually to stop the default submit. The preventDefault used in editDiagram is not
  // working for these since in draw.io code is called stopPropagation.
  //
  var fixEditorButtons = function(editor) {
    editor.find('button:not([type])').each(function() {
      $(this).attr('type', 'button');
    });
  };

  // mxRuler adds the ruler to the document body instead of adding it to the editor container.
  var originalMxDualRuler = mxDualRuler;
  mxDualRuler = function(editorUI, unit) {
    originalMxDualRuler.apply(this, arguments);
    $([this.hRuler.container, this.vRuler.container]).appendTo(editorUI.container);
  };
  mxDualRuler.prototype = Object.create(originalMxDualRuler.prototype);
  mxDualRuler.prototype.constructor = mxDualRuler;

  var themes = {};
  var getDiagramEditorConfig = function(container) {
    var input = $(container).children('input.diagram-content');
    var documentReference = input.data('reference') || '';
    if (typeof documentReference === 'string') {
      documentReference = XWiki.Model.resolve(documentReference, XWiki.EntityType.DOCUMENT,
        XWiki.currentDocument.documentReference);
    }
    var fileName = input.data('title') || $('#document-title').text();
    if (!fileName) {
      fileName = documentReference.name == 'WebHome' ? documentReference.parent.name : documentReference.name;
    }
    return {
      container: container,
      themes: themes,
      fileName: fileName,
      input: input,
      documentReference: documentReference
    };
  };

  //
  // jQuery plugin
  //
  $.fn.editDiagram = function(options) {
    return this.on('click', 'button', function(event) {
      // Make sure the buttons from the editor UI don't submit the edit form.
      event.preventDefault();
    }).on('keydown keyup keypress', '.geContentEditable', function(event) {
      // Make sure the keyboard events triggered from the nested editable sections are not propagated as they may
      // trigger shortcut keys (the nested editable sections need to behave like input fields).
      // See issue #15: If you install XWebIDE Application you can't use "W" letter in the diagram text.
      event.stopPropagation();
    }).each(function() {
      // We need this CSS class on the body element in order to have proper styling for the UI elements (menus, dialogs,
      // tooltips) that are added directly under the body element.
      $(document.body).addClass('geEditor');
      createDiagramEditor($.extend(getDiagramEditorConfig(this), options));
      $(this).removeClass('loading');
    });
  };

  return diagramUtils.loadTranslationAndTheme().done(function(theme) {
    // Configure the default editor theme.
    themes[Graph.prototype.defaultThemeName] = theme;
  });
});</code>
    </property>
    <property>
      <name>Diagram Editor</name>
    </property>
    <property>
      <parse>1</parse>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <object>
    <name>Diagram.DiagramEditSheet</name>
    <number>3</number>
    <className>XWiki.JavaScriptExtension</className>
    <guid>1787d86a-d14d-400e-94d8-6de104a43cde</guid>
    <class>
      <name>XWiki.JavaScriptExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <defaultValue>long</defaultValue>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage|onDemand|always</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>require.config({
  paths: {
    'diagram-setup': new XWiki.Document('DiagramSheet', 'Diagram').getURL('jsx', 'minify=$!services.debug.minify')
  },
  map: {
    'diagram-utils': {
      'mxgraph-common': 'mxgraph-editor'
    },
    'diagram-link-handler': {
      'draw.io.common': 'draw.io'
    }
  }
});

require(['diagram-setup'], function() {
  require(['jquery', 'diagram-editor'], function($, diagramEditorPromise) {
    diagramEditorPromise.done(function() {
      $('.diagram-editor').editDiagram();
    });
  });
});</code>
    </property>
    <property>
      <name>Startup</name>
    </property>
    <property>
      <parse>1</parse>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
</xwikidoc>
